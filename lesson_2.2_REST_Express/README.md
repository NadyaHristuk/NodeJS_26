# NodeJS_26

## REST: простым языком
### Особенности реализации API.

![enter image description here](https://s.dou.ua/storage-files/AngularREST1.png)

**Оглавление**

 1. Клиент и сервер
 2. Особенности архитектурного стиля 
 3. Когда использовать REST 
 4. Что такое RESTful
 5. HTTP методы для создания RESTful сервисов 
 6. Пример REST API c использованием Node.js и Express.js 
    Литература


**1. Клиент и сервер**

**Сервером**  в данном случае мы считаем абстрактную машину в сети, способную получить HTTP-запрос, обработать его и вернуть корректный ответ. В контексте данной статьи совершенно не важны его физическая суть и внутренняя архитектура, будь то студенческий ноутбук или огромный кластер из промышленных серверов, разбросанных по всему миру. Нам в той же мере совершенно неважно, что у него под капотом, кто встречает запрос у дверей, Apache или Nginx, какой неведомый зверь, PHP, Python или Ruby выполняет его обработку и формирует ответ, какое хранилище данных используется: Postgresql, MySQL или MongoDB. Главное, чтобы сервер отвечал главному правилу — услышать, понять и  ~~простить~~  ответить.

**Клиентом**  тоже может быть все, что угодно, что способно сформировать и отправить HTTP-запрос. До определенного момента в этой статье нам также не особо будут интересны цели, которые ставит перед собой клиент, отправляя этот запрос, как и то, что он будет делать с ответом. Клиентом может быть JavaScript-сценарий, работающий в браузере, мобильное приложение, злой (или не очень) демон, запущенный на сервере, или слишком поумневший холодильник (уже есть и такие).

_По большей части мы будем говорить о способе общения между выше перечисленными двумя, таком способе, чтобы они друг друга понимали, и ни у одного не оставалось вопросов._

***REST (REpresentational State Transfer)*** — это архитектура, т.е. принципы построения распределенных гипермедиа систем, того что другими словами называется World Wide Web, включая универсальные способы обработки и передачи состояний ресурсов по HTTP.

Автор идеи и термина Рой Филдинг 2000г.

***REST (Representational state transfer)*** изначально был задуман как простой и однозначный интерфейс для управления данными, предполагавший всего несколько базовых операций с непосредственным сетевым хранилищем (сервером): извлечение данных (GET), сохранение (POST), изменение (PUT/PATCH) и удаление (DELETE). Разумеется, этот перечень всегда сопровождался такими опциями, как обработка ошибок в запросе (корректно ли составлен запрос), разграничение доступа к данным (вдруг этого вам знать не следует) и валидация входящих данных (вдруг вы написали ерунду), в общем, всеми возможными проверками, которые сервер выполняет перед тем, как выполнить желание _клиента_.

Для веб-сервисов или API, построенных с учётом REST (то есть не нарушающих накладываемых им ограничений), применяют термин **«RESTful»**.

**REST**  – достаточно распространенный в интернете способ взаимодействия клиентских приложений и сервисов. Сервис, написанный с учетом ограничений и правил  REST  принято называть  **RESTful**.

Очень важно следующее:  **REST  – это НЕ протокол или стандарт.**  
В отличие от веб-сервисов на основе SOAP, не существует утвержденного или принятого официально стандарта для RESTful сервисов.  **REST  является  _архитектурой_**, в то время как SOAP является  _протоколом_.  

То есть  **REST  – это набор принципов и ограничений взаимодействия клиента и сервера**  в сети интернет, использующий существующие стандарты (HTTP протокол, стандарт построения URL, форматы данных JSON и XML) в ходе взаимодействия.

**1. Особенности архитектурного стиля**

Помимо этого REST имеет ряд архитектурных принципов, перечень которых можно найти в любой другой статье о REST. Пробежимся по ним кратко, чтобы они были под рукой, и не пришлось никуда уходить:

**Независимость сервера от клиента**  — серверы и клиенты могут быть мгновенно заменены другими независимо друг от друга, так как интерфейс между ними не меняется. Сервер не хранит состояний клиента.  
**Уникальность адресов ресурсов**  — каждая единица данных (любой степени вложенности) имеет свой собственный уникальный URL, который, по сути, целиком является однозначным идентификатором ресурса.

**Пример:**  `GET /api/v1/users/25/name`

**Независимость формата хранения данных от формата их передачи**  — сервер может поддерживать несколько различных форматов для передачи одних и тех же данных (JSON, XML и т.д.), но хранит данные в своем внутреннем формате, независимо от поддерживаемых.

**Присутствие в ответе всех необходимых метаданных**  — помимо самих данных сервер должен возвращать детали обработки запроса, например, сообщения об ошибках, различные свойства ресурса, необходимые для дальнейшей работы с ним, например, общее число записей в коллекции для правильного отображения постраничной навигации. Мы еще пройдемся по разновидностям ресурсов.

-   Каждая сущность должна иметь уникальный идентификатор – URI.
-   Сущности должны быть связаны между собой.
-   Для чтения и изменения данных должны использоваться стандартные методы.
-   Должна быть поддержка нескольких типов ресурсов.
-   Взаимодействие должно осуществляться без состояния.

Стандартные методы таковы:

-   GET – получение данных без их изменения. Это наиболее популярный и легкий метод. Он только возвращает данные, а не изменяет их, поэтому на клиенте вам не нужно заботиться о том, что вы можете повредить данные.
-   POST – метод, подразумевающий вставку новых записей.
-   PUT – метод, подразумевающий изменение существующих записей.
-   PATCH – метод, подразумевающий изменение идентификатора существующих записей.
-   DELETE – метод, подразумевающий удаление записей.

**3. Что такое RESTful:**

Чтобы распределенная система считалась сконструированной по REST архитектуре (Restful), необходимо, чтобы она удовлетворяла следующим критериям:

1.  **Client-Server.**  Система должна быть разделена на клиентов и на серверов. Разделение интерфейсов означает, что, например, клиенты не связаны с хранением данных, которое остается внутри каждого сервера, так что мобильность кода клиента улучшается. Серверы не связаны с интерфейсом пользователя или состоянием, так что серверы могут быть проще и масштабируемы. Серверы и клиенты могут быть заменяемы и разрабатываться независимо, пока интерфейс не изменяется.
2.  **Stateless.**  Сервер не должен хранить какой-либо информации о клиентах. В запросе должна храниться вся необходимая информация для обработки запроса и если необходимо, идентификации клиента.
3.  **Cache․**  Каждый ответ должен быть отмечен является ли он кэшируемым или нет, для предотвращения повторного использования клиентами устаревших или некорректных данных в ответ на дальнейшие запросы.
4.  **Uniform Interface.**  Единый интерфейс определяет интерфейс между клиентами и серверами. Это упрощает и отделяет архитектуру, которая позволяет каждой части развиваться самостоятельно.

**Важно !** Сама архитектура REST не привязана к конкретным технологиям и протоколам, но в реалиях современного Веб, построение RESTful API почти всегда подразумевает использование HTTP и каких-либо распространенных форматов представления ресурсов, например JSON, или, менее популярного сегодня, XML.

**4. HTTP методы для создания RESTful сервисов**

**HTTP метод GET**  используется для получения (или чтения) представления ресурса. В случае “удачного” (или не содержащего ошибок) адреса, GET возвращается представление ресурса в формате XML или JSON в сочетании с кодом состояния HTTP 200 (OK). В случае наличия ошибок обычно возвращается код 404 (NOT FOUND) или 400 (BAD REQUEST).

-   **_GET_** [**_http://www.example.com/api/v1.0/users_**](http://www.example.com/api/v1.0/users)  _(вернуть список пользователей)_
-   **_GET_** [**_http://www.example.com/api/v1.0/users/12345_**](http://www.example.com/api/v1.0/users/12345)  _(вернуть данные о пользователе с id 12345)_
-   **_GET_** [**_http://www.example.com/api/v1.0/users/12345/orders_**](http://www.example.com/api/v1.0/users/12345/orders)

**HTTP метод PUT**  обычно используется для предоставления возможности обновления ресурса. Тело запроса при отправке PUT-запроса к существующему ресурсу URI должно содержать обновленные данные оригинального ресурса (полностью, или только обновляемую часть).

Для создания новых экземпляров ресурса предпочтительнее использование POST запроса. В данном случае, при создании экземпляра будет предоставлен корректный идентификатор экземпляра ресурса в возвращенных данных об экземпляре.

При успешном обновлении посредством выполнения PUT запроса возвращается код 200 (или 204 если не был передан какой либо контент в теле ответа). PUT не безопасная операция, так как вследствии ее выполнения происходит модификация (или создание) экземпляров ресурса на стороне сервера, но этот метод идемпотентен. Другими словами, создание или обновление ресурса посредством отправки PUT запроса — ресурс не исчезнет, будет располагаться там же, где и был при первом обращении, а также, многократное выполнение одного и того же PUT запроса не изменит общего состояния системы

-   **_PUT_** [**_http://www.example.com/api/v1.0/users/12345_**](http://www.example.com/api/v1.0/users/12345)  _(обновить данные пользователя с id 12345)_
-   **_PUT_** [**_http://www.example.com/api/v1.0/users/12345/orders/98765_**](http://www.example.com/api/v1.0/users/12345/orders/98765)  _(обновить данные заказа с id 98765 для пользователя с id 12345)_

**HTTP метод POST** запрос наиболее часто используется для создания новых ресурсов. На практике он используется для создания вложенных ресурсов. Другими словами, при создании нового ресурса, POST запрос отправляется к родительскому ресурсу и, таким образом, сервис берет на себя ответственность на установление связи создаваемого ресурса с родительским ресурсом, назначение новому ресурсу ID и т.п.

При успешном создании ресурса возвращается HTTP код 201, а также в заголовке `Location` передается адрес созданного ресурса.

POST не является безопасным или идемпотентным запросом. Потому рекомендуется его использование для не идемпотентных запросов. В результате выполнения идентичных POST запросов предоставляются сильно похожие, но не идентичные данные.

-   **_POST_** [**_http://www.example.com/api/v1.0/customers_**](http://www.example.com/api/v1.0/customers)  _(создать новый ресурс в разделе customers)_
-   **_POST_** [**_http://www.example.com/api/v1.0/customers/12345/orders_**](http://www.example.com/api/v1.0/customers/12345/orders)  _(создать заказ для ресурса с id 12345)_

**HTTP метод DELETE** используется для удаления ресурса, идентифицированного конкретным URI (ID).

При успешном удалении возвращается 200 (OK) код HTTP, совместно с телом ответа, содержащим данные удаленного ресурса. Также возможно использование HTTP кода 204 (NO CONTENT) без тела ответа. Согласно спецификации HTTP, DELETE запрос идемпотентен. Если вы выполняете DELETE запрос к ресурсу, он удаляется. Повторный DELETE запрос к ресурсу закончится также: ресурс удален. Если DELETE запрос используется для декремента счетчика, DELETE запрос не является идемпотентным. Используйте POST для не идемпотентных операций.

Тем не менее, существует предостережение об идемпотентности DELETE. Повторный DELETE запрос к ресурсу часто сопровождается 404 (NOT FOUND) кодом HTTP по причине того, что ресурс уже удален (например из базы данных) и более не доступен. Это делает DELETE операцию не идемпотентной, но это общепринятый компромисс на тот случай, если ресурс был удален из базы данных, а не помечен, как удаленный.

-   **_DELETE_** [**_http://www.example.com/api/v1.0/customers/12345_**](http://www.example.com/api/v1.0/customers/12345)  _(удалить из customers ресурс с id 12345)_
-   **_DELETE_** [**_http://www.example.com/api/v1.0/customers/12345/orders_**](http://www.example.com/api/v1.0/customers/12345/orders)**_/21_** _(удалить у ресурса с id 12345 заказ с id 21)_

 **Литература**
[REST: простым языком](https://medium.com/@andr.ivas12/rest-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%8B%D0%BC-%D1%8F%D0%B7%D1%8B%D0%BA%D0%BE%D0%BC-90a0bca0bc78)
[# REST. Описание концепции. Особенности реализации API. Максимально кратко.](https://ziginsider.github.io/rest-api/)
[# Грамотная клиент-серверная архитектура: как правильно проектировать и разрабатывать web API](https://tproger.ru/articles/web-api/)