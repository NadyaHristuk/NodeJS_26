## Тестирование
Добро пожаловать в интерактивное методическое пособие, созданное с любовью в школе LoftSchool.

/	
Оглавление

Когда нужно и не нужно тестировать
Основные термины (пирамида, TDD, BDD, stubs, mock)
Пишем тесты правильно(требования, оценка результата)
Выбор фреймворка для создания тестов
Примеры тестирования REST сервиса с использование Mocha и Chai
Литература
Тестирование — это процесс в программировании, позволяющий проверить на корректность отдельные модули исходного кода программы.
1. Когда нужно и не нужно тестировать
Всегда ли нужно тестировать ваше приложение? Рекомендуем ответить вам самим на этот вопрос после следующего утверждения: "Любой долгосрочный проект без надлежащего покрытия тестами обречен рано или поздно быть переписанным с нуля".

Однако существуют ситуации, когда необходимость в написании тестов не столь очевидна. Скорее всего тесты не нужны вам если:

Вы всегда пишете код для себя, создавая pet проект, не имея планов на его дальнейшее коммерческое использование или распространение в рамках сообщества.

Вы создаете рекламные одностраничники, продающие страницы, простые флеш-играми или баннеры – сложная верстка/анимация или большой объем статики. Никакой логики нет, только представление.

Создание статического сайта-визитки, т.е. 1-4 html-страницы с одной или несколькими формами для отправки данных. Тут закономерно нет никакой особенной логики, быстрее просто все проверить самостоятельно, так сказать «руками».

Вы делаете рекламный проект для выставки. Срок работы – от нескольких недель до месяца. В начале проекта не до конца известно, что именно должно получиться в конце. Задача проекта — отработать несколько дней на выставке в качестве презентации.

В представленных вариантах по объективным причинам (сжатые сроки, бюджеты, размытые цели или очень простые требования) вы не получите выигрыша от написания тестов.
2. Основные термины
Существует несколько подходов к написанию тестов.

Первая модель — классика: сначала разработка, а затем тестирование
"code first". Это означает, что сначала происходит написание кода, затем мы тестируем продукт и отправляем его или на доработку, или переходим к следующей стадии разработки.

Другой подход можно назвать "test first" режимом. Это означает, что мы можем начать тестирование еще до написания самой функции — например, мы можем создать единичный тест или автоматически выполняемый набор тестов до того, как функция или какой-то кусок кода будет разработан и внедрен в приложение. Одним из наиболее популярных примеров здесь является Test-Driven Development.


Тем не менее, стоит упомянуть, что техника "test first" не так популярна, как "code first". Это связано с тем, что в большинстве проектов все еще сложно автоматизировать что то, что еще не было разработано. Обобщая оба упомянутых выше подхода, можно сделать вывод, что нет особой разницы и что автоматизацию тестов мы можем использовать в любом из вариантов. Ни один из этих подходов не может считаться хорошим или плохим и выбор в первую очередь зависит от проекта т.е. каждый конкретный случай следует рассматривать отдельно.


Также наряду с термином ТDD вы можете услышать и о BDD подходе.

В основе Test-driven development (TDD) лежит 5 основных этапов:

Сначала разработчик пишет несколько тестов.

Затем разработчик запускает эти тесты и (очевидно) они терпят неудачу, потому что ни одна из этих функций еще не реализована.

Далее разработчик действительно реализует эти тесты в коде.

Если разработчик хорошо пишет свой код, то на следующем этапе он увидит, что тесты проходят.

Разработчик может затем реорганизовать свой код, добавить комментарии так как он уверен, что если новый код что-то сломает, тогда тесты предупредят об этом.
test('равно 1 для массива с одним элементом', function (){
   assert.equal(1,[1].length);
});
Behavior-driven development (BDD) — подход создан для того, чтобы исправить проблемы, которые могут возникнуть при использовании ТDD, а именно, обеспечить лучшее взаимопонимание внутри команды, т.е. не только для разработчиков, облегчить поддержку кода через наглядное представление о его функциональности, тесты и их результаты выглядят более "человечно", облегчается процесс миграции при переходе на другой язык программирования.


В варианте с BDD — в начале мы описываем поведение и спецификации, которые затем управляют нашей разработкой программного обеспечения. Поведение и спецификации могут показаться ужасно похожими на тесты, но разница очень тонкая и важная.

Это, по сути, создание плана перед тем, как вы начинаете писать код. Т.е в начале описываем, что должно происходить, каково поведение функции (в заголовках тестов пишем, не что мы проверяем, а то, что мы ожидаем от работы еще не реализованной функциональности), затем пишем тесты и наконец, сам код.
it('должно вернуть 1, когда передан массив с одним элементов', function (){
[1].length.should.equal(1);
});
Еще одной важной концепцией тестирования является тестовая пирамида. Пирамида тестирования используется для распределения тестов по уровням приложения.

Каждое приложение можно разделить на несколько слоев. Рассмотрим типичное расслоение с уровнем компонентов, сервисами и пользовательским интерфейсом. Нижняя часть пирамиды покрыта модульными (unit) тестами. Они написаны в основном разработчиками и охватывают атомарные компоненты, такие как классы, методы и функции. Запускаются очень часто, работаю быстро и их количество в рамках приложения велико.
Б. Страустрап в своей книге о C++ предлагает следующий подход к разделению кода на отдельные блоки: если «это» действие — сделайте метод. Если несколько действий объединены общим смыслом и/или процессом — объявите класс. Если придерживаться этого правила, то автоматически класс будет модулем вашего приложения.

Бьёрн Страуструп
Программист
Следующий уровень — интеграционные тесты. Т.е. когда идет проверка, не ломает ли новый функционал код, который уже написан ранее в рамках системы. Также тут мы можем иметь сценарии, которые охватывают более сложные функции, такие как тесты API. Запускаем реже, как правило, при мердже веток или объединении больших участков кода.

В верхней части находятся тесты пользовательского интерфейса (end to end) Они действуют так же, как конечный пользователь работает с приложением. Запускаем очень редко — несколько раз за проект. Работают очень медленно.

Процесс автоматизации тестирования характеризуется движением от основания пирамиды к ее вершине. Если одно задание терпит неудачу, то мы начинаем с самого начала. Этот конвейер продолжается до тех пор, пока весь набор тестов не будет выполнен и в случае успеха будет проведен коммит или мердж веток. Возможен также параллельный запуск тестов для сокращения времени, необходимого для выполнения всех заданий.
Еще один набор терминов, с которыми придется столкнуться в процессе написания тестов — это стабы (stubs) и моки (mock).

Очень часто наш код (функция, модуль) имеют внешние зависимости. Внешняя зависимость — это все, что делает ваши тесты не правдивыми и сложно-поддерживаемыми. Файловая система — зависимость: структура каталогов может быть другой на другой машине. База данных — зависимость, ее может не быть на другой машине. Веб-сервис — зависимость: может не быть интернета или может присутствовать фаервол и.т.д

Если на вопрос: «будет ли этот компонент вести себя так же на другой машине?» вы отвечаете нет, то его необходимо "подменить" и тут вам на помощь как раз придут стабы и моки. Но есть и другая сторона медали, когда разработчик начинает увлекаться и приходит к тому, что подменяет вообще все. Соответственно тесты перестают проверять само приложение и начинают тестировать стабы, моки. Это в корне не верно. Если «живых» реализаций в тесте нет, то этот тест не тестирует ничего.

Иногда эти термины stubs и mock путают: разница в том, что стаб ничего не проверяет, а лишь имитирует заданное состояние. А мок – это объект, у которого есть ожидания. Например, что данный метод класса должен быть вызван определенное число раз. Иными словами, ваш тест никогда не сломается из-за «стаба», а вот из-за мока может.

С технической точки зрения это значит, что, используя стабы, мы проверяем состояние тестируемого класса или результат выполненного метода. При использовании мока мы проверяем, соответствуют ли ожидания мока поведению тестируемого класса. Также лучше использовать не более одного мока на тест. Иначе с высокой вероятностью вы нарушите принцип «тестировать только одну вещь». При этом, в одном тесте может быть сколько угодно стабов или же мок и стабы.

Есть уже готовые фреймворки, которые предоставляют такой функционал: Sinon, Jasmine, enzyme, Jest, testdouble
Пример использования стаба (sinonjs.org)
it('resolves with the right name', done => {
 const stub = sinon.stub(User.prototype, 'fetch')
   .resolves({ name: 'David' })

 User.fetch()
   .then(user => {
     expect(user.name).toBe('David')
     done()
   })
})
3. Пишем тесты правильно
(требования, оценка результата)
На сегодняшний день, к сожалению, сохраняется ситуация, когда тесты к проекту написаны, но что они тестируют, и какой от них ожидается результат, в полной мере неизвестно. Чаще всего это результат бездумного написания тестов, что не только не помогает, но вредит проекту. Тесты написанные без учета архитектуры и конкретного плана действий только осложняют сопровождение и поддержку, так как вместо одного некачественного продукта вы получаете два.

Есть несколько рекомендаций, придерживаясь которых, вы можете избежать данной проблемы.
1	
Тесты в пределах проекта должны быть расположены в соответствии с общей логикой и должны быть частью системы контроля версий. Например, если приложение монолитное, положите все тесты в папку test; если у вас много разных компонентов, храните тесты в папке каждого компонента.
2	
Особое внимание уделите именованию тестов.

Одна из лучших практик: добавьте к каждому проекту его собственный тестовый проект. Если у вас, например, есть части системы your-project.models, your-project.controllers, то тесты для этих частей могут именоваться следующим образом: your-project.models.tests, your-project.controllers.tests
3	
Такие же "логичные" походы используйте для именования тестовых классов или методов.

Например, один из вариантов именования для тестирования метода — <метод>_<cценарий>_<результат>.

Метод калькулятора суммирующий данные
Sum_2Plus5_Returned7
4	
Каждый тестирующий класс или метод должен тестировать только одну сущность. Если процесс слишком сложен (например, покупка в интернет-магазине), разделите его на несколько частей и протестируйте их отдельно.
5	
Не делайте ненужных утверждений (assertion). Какое конкретное поведение вы тестируете? Если это не основное поведение, то оно и не нуждается в тестировании! Помните, что модульные тесты — это спецификация дизайна того, как должно срабатывать определенное поведение, а не список наблюдений за всем кодом.
6	
Вы определенно ошиблись, если вам нужно запускать тесты в определенном порядке, или если они работают только при активной базе данных или сетевом соединении.
7	
Не стоит писать велосипеды. Пользуйтесь готовыми тестовыми фреймворками. Подберите тот, который подходит вам в данном, конкретном случае.
8	
Боритесь с зависимостями. Тесты не должны зависеть от окружения, в котором они выполняются. Например, не проверяйте настройки конфигурации устройства. По необходимости используйте стабы и моки, а также готовые фреймворки для их написания.
9	
Не относитесь к своим тестам как к второсортному коду. Все принципы, применяемые в разработке продакшн-кода могут и должны применяться при написании тестов. (DRY, KISS)
10	
Тест должен легко поддерживаться. Есть всего три причины, почему тест перестал проходить:

Ошибка в продакшн-коде: это баг, его нужно завести в баг-трекере и починить.
Баг в тесте: видимо, продакшн-код изменился, а тест написан с ошибкой (например, тестирует слишком много или не то, что было нужно).
Смена требований. Если требования изменились слишком сильно – тест должен упасть. Это правильно и нормально. Вам нужно разобраться с новыми требованиями и исправить тест. Или удалить, если он больше не актуален.
11	
Тесты должны запускаться регулярно в автоматическом режиме.
Определить успешность вашей системы тестирования на проекте можно двумя способами:

Количество багов в новых релизах (в т.ч. и регрессии).
Покрытие кода

Первый показывает, есть ли у наших действий результат, или мы впустую расходуем время. Второй – как много нам еще предстоит сделать.

Тестовое покрытие — полезный инструмент для поиска непроверенных частей кодовой базы. Тестовый охват мало полезен в качестве числового заявления о том, насколько хороши ваши тесты. "Нормальным" считается покрытие в пределах 80%.

Наиболее популярные инструменты для измерения покрытия кода, написанного на JavaScript istanbul.js blanket.js JSCover
4. Выбор фреймворка
На сегодняшний день доступна целая масса фреймворков для тестирования JavaScript-кода (overview).

Учитывая подобное разнообразие, выбор того или иного фреймворка, как правило, напрямую зависит от непосредственной задачи, которую мы ставим перед собой в процессе написания тестов. Идеально, когда функционал фреймворка покрывает несколько или все поставленные задачи (единая среда).

Например, поддерживаемая структура тестов. Если мы говорим о поддержке BDD, то следует выбирать среди Mocha, Jasmine, Jest, Сucumber.

Также доступны на выбор несколько assertion библиотек: Chai, Jasmine, Jest, Unexpected.

Если для вас важную роль играет представление и отображение результатов ваших проверок, то наибольший функционал в данной области предоставляют Mocha, Jasmine, Jest, Karma.

Для использования snap-shots в вашем тестировании следует обратить внимание на Jest или Ava.

Для борьбы с зависимостями и использования mocks и stubs следует обратить внимание на специализированные фреймворки типа Sinon.js, Jasmine, enzyme, Jest, testdouble.js.

Как уже упоминалось выше для измерения охвата и покрытия кода тестами возможно использование Istanbul, Jest.

Для функциональных тестов, для создания пользовательских сценариев поведения, необходимо использование браузерной среды или браузерной среды с программируемым API, что доступно в рамках Protractor, Nightwatch, Phantom.js, Сasper.
Описание некоторых фреймворков.

JSDOM является реализацией JavaScript-стандартов WHATWG DOM и HTML. Другими словами, JSDom имитирует среду браузера, не запуская ничего, кроме простого JS. В этой моделируемой среде браузера тесты могут выполняться очень быстро. Недостатком JSDom является то, что не все может быть смоделировано вне реального браузера (например, вы не можете сделать снимок экрана), поэтому его использование ограничивает доступность ваших тестов.

Istanbul — расскажет вам, сколько вашего кода покрывается модульными тестами. Он будет сообщать о показателях, линиях, функциях в процентах, чтобы вы лучше поняли, что осталось покрыть.

Phantom.js — реализует «headless» браузер Webkit, который находится между реальным браузером и JSDom в скорости и стабильности. Достаточно популярен.

Karma — позволяет запускать тесты в браузерах, включая настоящие браузеры, Phantom, JSdom и даже устаревшие браузеры. Karma размещает тестовый сервер со специальной веб-страницей для запуска тестов в среде страницы. Эта страница может быть запущена во многих браузерах. Это также означает, что тесты можно запускать удаленно с помощью таких служб, как BrowserStack.

Chai — самая популярная assertion библиотека.

Unexpected — это также assertion библиотека с немного отличающимся синтаксисом от Chai.

Sinon.js — это набор очень мощных тестовых шпионов, заглушек и макетов (mocks) для модульного тестирования.

testdouble.js — представляет собой новую библиотеку, похожую на Sinon, с несколькими отличиями в дизайне, философии и особенностях, которые могли бы пригодиться во многих случаях.

Jasmine — представляет собой платформу тестирования, обеспечивающую все, что вам требуется для ваших тестов: работающая среда, структура, отчетность, assertion и mocks инструменты.

Mocha — в настоящее время является наиболее часто используемой библиотекой. В отличие от Jasmine, она используется со сторонними библиотеками mocks и assertions (обычно Enzyme и Chai). Это означает, что Mocha немного сложнее настроить, но она более гибкая и открыта для расширений.

Jest — это платформа тестирования, рекомендованная Facebook. Он использует функционал Jasmine и добавляет функции поверх него, поэтому все упоминания о Jasmine относится и к нему.

Ava — минималистическая библиотека, которая имеет возможность запускать тесты параллельно.

Selenium — автоматизирует браузер для имитации поведения пользователя. Он не написан специально для тестов и может управлять браузером для многих целей, предоставляя сервер, который имитирует поведение пользователя в браузере с использованием API. Selenium можно контролировать разными способами и использовать различные языки программирования, а также с некоторыми инструментами даже без реального программирования.

Protractor — это библиотека, которая использует Selenium, но добавляет улучшенный синтаксис и специально встроенные хуки для Angular.

Nightwatch — имеет собственную реализацию selenium WebDriver. И обеспечивает собственную среду тестирования, тестовый сервер, assertion и другие инструменты.

Сasper — написан поверх Phantom и Slimer (так же, как Phantom, но в Gecko FireFox), чтобы при помощи специальных утилиты более просто создавать Phantom и Slimer скрипты. Каспер предоставляет нам более быстрый, но менее стабильный способ запуска функциональных тестов в браузерах с интерфейсом UI.

Сucumber — еще один замечательный фреймворк для функционального тестирования. Включает в себя весь основной функционал, ранее перечисленный в похожих фреймворках.
5. Примеры тестирования REST сервиса
(с использование Mocha и Chai)
Mocha — это JavaScript framework для Node.js, который позволяет выполнять асинхронное тестирование. Кроме того, позволяет использовать дополнительные библиотеки (assertion, mocks).

Chai — это assertion библиотека, с возможностью декларативного изложения утверждений.

Также будем использовать Chai-HTTP, модуль который позволяет Chai работать HTTP-запросами.

В качестве замены базы данных будем использовать lowdb
Устанавливаем необходимые npm-пакеты
npm install express lowdb -S
npm install mocha chai chai-http -D
Добавляем в package.json строку для запуска тестов
"scripts": {
   "start": "node ./server.js ",
   "test": "mocha"
}
Файл базы данных ./db.json будет содержать тестовые данные в JSON формате
{
  "users": [
    {
      "firstName": "Alan",
      "lastName": "Johnson",
      "phone": "1234567890",
      "email": "alan@test.com",
      "memberSince": "Mar 25, 2011"
    },
    {
      "firstName": "Allison",
      "lastName": "House",
      "phone": "0987654321",
      "email": "allison@test.com",
      "memberSince": "Jan 13, 2011"
    }
  ]
}
Пример основного файла приложения ./server.js
// подключаем локальную базу данных
const low = require('lowdb');
const FileSync = require('lowdb/adapters/FileSync');
const adapter = new FileSync('db.json');
const db = low(adapter);
// подключаем express
const express = require('express');
const app = express();
const router = express.Router();
// для парсинга параметров переданных через POST запрос
app.use(express.urlencoded({ extended: true }));
app.use(express.json());
// описание корневого роута
router.get('/', (req, res) => {
 res.json({ message: 'hooray! welcome to our api!' });
});
// GET /users — получаем список всех пользователей
router.route('/users')
 .get((req, res) => {
   res.send(
     db.get('users')
       .value()
   );
 })
// POST /users — добавляем пользователя
 .post((req, res) => {
   const {
     firstName,
     lastName = null,
     phone = null,
     email = null,
     memberSince = null
   } = req.body;
   if (!firstName) res.status(400).send({error: 'Missing required parameter - firstName'});
   db.get('users')
     .push({firstName, lastName, phone, email, memberSince})
     .write();
   const peopleLength = db.get('users').value().length;
   res.header('Location', `http://localhost:3000/api/v1.0/users/${peopleLength}`);
   res.status(201).send('User added');
 });
// GET /users/:user_id - получаем данные о пользователе по его id
router.route('/users/:user_id')
 .get((req, res) => {
   const userId = req.params.user_id;
   const singleUser = db.get(`users[${userId}]`).value();
   if (!singleUser)  res.status(404).send({ error: 'Not found'});
   res.send(singleUser);
 })
// DELETE /users/:user_id - удаляем пользователя по его id
 .delete((req, res) => {
   const userId = req.params.user_id;
   const singleUser = db.get(`users[${userId}]`).value();
   if (!singleUser) res.status(404).send({error: 'Not found'});
   db.get('users')
     .remove({firstName: singleUser.firstName})
     .write();
   res.send(singleUser);
 });
// Добавляем маршрут api
app.use('/api/v1.0', router);
app.use('*', (req, res) => {
 res.status(404).send({error: 'Not found. API is on http://localhost:3000/api/v1.0'});
});
// Обработчик ошибок
app.use(function (err, req, res, next) {
 res.status(err.status || 500).json({status: err.status, message: err.message});
});
// Запуск сервера
app.listen(3000, () => console.log('Example app listening on port 3000!'));

Создаем файл api.test.js в папке ./test
//подключаем все необходимые библиотеки
const chai = require('chai');
const expect = chai.expect;
const chaiHttp = require('chai-http');
const server = require('../server');
chai.use(chaiHttp); // подключаем chai-http к chai


// Тестируем /GET users
describe('/GET users', () => {
//должно возвращать данные при верном запросе
 it('it should GET all the users', (done) => {
   chai.request(server)
     .get('/api/v1.0/users')
     .end((err, res) => {
       expect(res).to.have.status(200); // ответ должен иметь статус 200
       expect(res.body).to.be.a('array'); // данные должны вернуться в виде массива
       expect(res.body.length).to.not.be.equal(0); // длина массива не должна быть равной нулю
       done(); // колбек, позволяющий работать с асинхронными запросами
     });
 });
//при ошибочном запросе должно возвращать верную ошибку
 it('it should return a right error for the wrong GET request', (done) => {
   chai.request(server)
     .get('/api/v1.0/user')
     .end((err, res) => {
       if (err || !res.ok) {
         expect(err).to.have.status(404); // ответ должен иметь статус 404
         done();
       } else {
         done(new Error('the route is not wrong'));
       }
     });
 });
});
// Тестируем /GET users:/id
describe('GET /users/:id', () => {
//должно возвращать данные о пользователе по его id
 it('it should return the user by id', (done) => {
   const user = db.get('users').first().value();
   const userId = db.get('users').value().indexOf(user);
   chai.request(server)
     .get('/api/v1.0/users/' + userId)
     .end((err, res) => {
       expect(res).to.have.status(200); // ответ должен иметь статус 404
       expect(res.body).to.deep.equal(user); // ответ должен содержать объект с данными пользователя
       done();
     });
 });
//если id не найден должно возвращать верную ошибку
 it('it should return status 404 when user id is not found', (done) => {
   const userId = 'fake id';
   chai.request(server)
     .get('/api/v1.0/users/' + userId)
     .end((err, res) => {
       if (err || !res.ok) {
         expect(err).to.have.status(404); // ответ должен иметь статус 404
         done();
       } else {
         done(new Error('the id is found'));
       }
     });
 });
});

// Тестируем /POST users
describe('/POST users', () => {
//должно создавать пользователя при верном запросе
 it('it should POST a user', (done) => {
   const user = {
     firstName: 'testUser'
   };
   chai.request(server)
     .post('/api/v1.0/users')
     .send(user)
     .end((err, res) => {
       expect(res).to.have.status(201); // ответ должен иметь статус 201
       expect(res.body).to.be.a('object'); 
       expect(res.body).to.have.property('message').equal('User added'); // ответ должен содержать объект с определенным сообщением
       expect(res).to.have.header('Location');
       expect(res.headers.location).to.match(/^http:\/\/\w+(\.\w+)*(:[0-9]+)?\/?(\/[.\w]*)*$/); // ответ должен содержать определенный хедер содержащий линк на созданный элемент (используем регулярный выражения)
       done();
     });
 });
//если нет обязательных полей в запросе то пользователь не должен быть создан 
 it('it should not POST a user without required field', (done) => {
   const user = {};
   chai.request(server)
     .post('/api/v1.0/users')
     .send(user)
     .end((err, res) => {
       expect(res).to.have.status(400);
       expect(res.body).to.be.a('object');
       expect(res).to.not.have.header('Location');
       done();
     });
 });
});

// Тестируем /DELETE users:/id

describe('DELETE /users/:id', () => {
//должно удалять пользователя и возвращать данные о нем по его id
 it('it should delete the user by id', (done) => {
   const user = db.get('users').last().value();
   const userId = db.get('users').value().indexOf(user);
   chai.request(server)
     .delete('/api/v1.0/users/' + userId)
     .end((err, res) => {
       expect(res).to.have.status(200);
       expect(res.body).to.deep.equal(user);
       done();
     });
 });
//если id не найден, должно возвращать верную ошибку
 it('it should return status 404 when user id is not found', (done) => {
   const userId = 'fake id';
   request
     .delete('/api/v1.0/users/' + userId)
     .end((err, res) => {
       if (err || !res.ok) {
         expect(err).to.have.status(404);
         done();
       } else {
         done(new Error('the user id is found'));
       }
     });
 });
});
Вывод в консоли после запуска mocha

По умолчанию mocha запускает все файлы тестов которые находятся в директории test
npm run test
….. 

Example app listening on port 3000!
  DELETE /users/:id
    ✓ it should delete the user by id
    ✓ it should return status 404 when user id is not found

  /GET users
    ✓ it should GET all the users
    ✓ it should return a right error for the wrong GET request

  GET /users/:id
    ✓ it should return the user by id
    ✓ it should return status 404 when user id is not found

  /POST users
    ✓ it should POST a user
    ✓ it should not POST a user without required field


  8 passing (113ms)

Все тесты отработали верно. Общее время 113ms
6. Литература
Книги
The Art of Unit Testing by Roy Osherove https://www.amazon.com/Art-Unit-Testing-Examples-Net/dp/1933988274
xUnit Test Patterns: Refactoring Test Code by Gerard Meszaros https://www.amazon.com/xUnit-Test-Patterns-Refactoring-Code/dp/0131495054/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1326315311&amp;sr=1-1
Working Effectively with Legacy Code by Michael Feathers  https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1326315365&amp;sr=1-1
Pragmatic Unit Testing in C# with NUnit by Andy Hunt and Dave Thomas https://www.amazon.com/Pragmatic-Unit-Testing-NUnit-2nd/dp/0977616673/ref=sr_1_2?s=books&amp;ie=UTF8&amp;qid=1326315408&amp;sr=1-2


Статьи

https://www.sitepoint.com/javascript
https://habrahabr.ru/post/169381/
https://joshldavis.com/2013/05/27/difference-between-tdd-and-bdd/
https://adamcod.es/2014/05/15/test-doubles-mock-vs...
https://www.quora.com/Software-Testing
https://medium.com/powtoon-engineering/
https://blog.jscrambler.com/testing-apis-mocha-2/
https://scotch.io/tutorials/test-a-node-restful-api-with-mocha-and-chai

Подкасты
The History of JUnit and the Future of Testing with Kent Beck - http://www.se-radio.net/2010/09/episode-167-the-history-of-junit-and-the-future-of-testing-with-kent-beck/
Kent Beck, Developer Testing - http://web.archive.org/web/20130729213428id_/http://itc.conversationsnetwork.org/shows/detail301.html